# -*- coding: utf-8 -*-
"""Calcola rho di Pearson per tutte le coppie di stazioni in un CSV.

Il CSV deve avere:
- prima colonna: data/tempo
- colonne successive: serie di portata delle stazioni

Supporta un filtro temporale opzionale:
- intervallo assoluto (YYYY-MM-DD ... YYYY-MM-DD)
- periodo stagionale ricorrente (MM-DD ... MM-DD, applicato a tutti gli anni)

Uso esempio:
python pearson_rho_stazioni.py \
  --input-csv "/percorso/al/file_input.csv" \
  --output-csv "/percorso/al/file_output.csv"
  --period-start 06-01 \
  --period-end 08-31
"""

from __future__ import annotations

import argparse
import csv
import math
import re
from dataclasses import dataclass
from datetime import date, datetime
from itertools import combinations
from pathlib import Path


DEFAULT_INPUT_CSV = Path("C:/Users/loren/Desktop/Tesi_magi/rho_meas/argenflow.csv")
DEFAULT_OUTPUT_CSV = Path("C:/Users/loren/Desktop/Tesi_magi/rho_meas/rho_stazioni.csv")
DEFAULT_PERIOD_START = "06-01"
DEFAULT_PERIOD_END = "08-31"

OUTPUT_PAIR_COLUMN = "stazioni"
OUTPUT_RHO_COLUMN = "rho"

DATE_FORMATS = (
    "%Y-%m-%d",
    "%d/%m/%Y",
    "%Y/%m/%d",
    "%d-%m-%Y",
)

MMDD_PATTERN = re.compile(r"^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$")


@dataclass(frozen=True)
class DateFilter:
    start: date
    end: date


@dataclass(frozen=True)
class SeasonalFilter:
    start_month: int
    start_day: int
    end_month: int
    end_day: int


PeriodFilter = DateFilter | SeasonalFilter


def parse_float(value: str) -> float | None:
    text = value.strip()
    if text == "":
        return None
    try:
        return float(text)
    except ValueError:
        return None

def parse_date(text: str) -> date | None:
    cleaned = text.strip()
    if not cleaned:
        return None

    for fmt in DATE_FORMATS:
        try:
            return datetime.strptime(cleaned, fmt).date()
        except ValueError:
            continue

    try:
        return datetime.fromisoformat(cleaned).date()
    except ValueError:
        return None


def parse_period_filter(period_start: str | None, period_end: str | None) -> PeriodFilter | None:
    if period_start is None and period_end is None:
        return None
    if period_start is None or period_end is None:
        raise ValueError("Per filtrare il periodo devi specificare sia --period-start sia --period-end.")

    start_text = period_start.strip()
    end_text = period_end.strip()

    start_is_mmdd = bool(MMDD_PATTERN.match(start_text))
    end_is_mmdd = bool(MMDD_PATTERN.match(end_text))

    if start_is_mmdd and end_is_mmdd:
        start_month, start_day = (int(part) for part in start_text.split("-"))
        end_month, end_day = (int(part) for part in end_text.split("-"))
        return SeasonalFilter(
            start_month=start_month,
            start_day=start_day,
            end_month=end_month,
            end_day=end_day,
        )

    start_date = parse_date(start_text)
    end_date = parse_date(end_text)
    if start_date is None or end_date is None:
        raise ValueError(
            "Formato periodo non valido. Usa YYYY-MM-DD (intervallo assoluto) "
            "oppure MM-DD (periodo stagionale ricorrente)."
        )
    if end_date < start_date:
        raise ValueError("In intervallo assoluto la data finale deve essere >= della data iniziale.")
    return DateFilter(start=start_date, end=end_date)


def is_in_period(current_date: date, period_filter: PeriodFilter | None) -> bool:
    if period_filter is None:
        return True

    if isinstance(period_filter, DateFilter):
        return period_filter.start <= current_date <= period_filter.end

    current_mmdd = (current_date.month, current_date.day)
    start_mmdd = (period_filter.start_month, period_filter.start_day)
    end_mmdd = (period_filter.end_month, period_filter.end_day)

    if start_mmdd <= end_mmdd:
        return start_mmdd <= current_mmdd <= end_mmdd

    return current_mmdd >= start_mmdd or current_mmdd <= end_mmdd



def pearson_rho(values_a: list[float | None], values_b: list[float | None]) -> float:
    paired: list[tuple[float, float]] = [
        (a, b)
        for a, b in zip(values_a, values_b)
        if a is not None and b is not None
    ]
    if not paired:
        return float("nan")

    x_values = [x for x, _ in paired]
    y_values = [y for _, y in paired]

    x_mean = sum(x_values) / len(x_values)
    y_mean = sum(y_values) / len(y_values)

    num = sum((x - x_mean) * (y - y_mean) for x, y in paired)
    den_a = sum((x - x_mean) ** 2 for x in x_values)
    den_b = sum((y - y_mean) ** 2 for y in y_values)
    den = math.sqrt(den_a * den_b)

    if den == 0:
        return float("nan")
    return num / den


def read_station_series(
    input_csv: str | Path,
    period_filter: PeriodFilter | None = None,
) -> tuple[list[str], dict[str, list[float | None]]]:
    input_path = Path(input_csv)
    if not input_path.exists():
        raise FileNotFoundError(f"File input non trovato: {input_path}")

    with input_path.open("r", newline="", encoding="utf-8") as f:
        reader = csv.reader(f)
        try:
            header = next(reader)
        except StopIteration as exc:
            raise ValueError("Il CSV di input Ã¨ vuoto.") from exc

        if len(header) < 3:
            raise ValueError(
                "Il CSV deve contenere almeno 3 colonne: data + almeno 2 stazioni."
            )

        station_names = header[1:]
        station_series: dict[str, list[float | None]] = {name: [] for name in station_names}

        for row_idx, row in enumerate(reader, start=2):
            padded_row = row + [""] * (len(header) - len(row))
            current_date = parse_date(padded_row[0])
            if current_date is None:
                raise ValueError(
                    "Formato data non riconosciuto nella prima colonna "
                    f"(riga {row_idx}): {padded_row[0]!r}. "
                    "Formati accettati: YYYY-MM-DD, DD/MM/YYYY, YYYY/MM/DD, DD-MM-YYYY."
                )
            if not is_in_period(current_date, period_filter):
                continue
            for idx, station_name in enumerate(station_names, start=1):
                station_series[station_name].append(parse_float(padded_row[idx]))

    return station_names, station_series


def compute_station_pair_rho(station_names: list[str], station_series: dict[str, list[float | None]]) -> list[dict[str, str]]:
    rows: list[dict[str, str]] = []

    for station_a, station_b in combinations(station_names, 2):
        rho = pearson_rho(station_series[station_a], station_series[station_b])
        rho_text = "nan" if math.isnan(rho) else f"{rho:.12g}"
        rows.append(
            {
                OUTPUT_PAIR_COLUMN: f"{station_a} - {station_b}",
                OUTPUT_RHO_COLUMN: rho_text,
            }
        )

    return rows


def write_output(output_csv: str | Path, rows: list[dict[str, str]]) -> Path:
    output_path = Path(output_csv)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with output_path.open("w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=[OUTPUT_PAIR_COLUMN, OUTPUT_RHO_COLUMN])
        writer.writeheader()
        writer.writerows(rows)

    return output_path


def run(
    input_csv: str | Path,
    output_csv: str | Path,
    period_start: str | None = None,
    period_end: str | None = None,
) -> Path:
    period_filter = parse_period_filter(period_start=period_start, period_end=period_end)
    station_names, station_series = read_station_series(input_csv, period_filter=period_filter)
    rows = compute_station_pair_rho(station_names, station_series)
    output_path = write_output(output_csv, rows)

    for row in rows:
        print(f"{row[OUTPUT_PAIR_COLUMN]} -> rho={row[OUTPUT_RHO_COLUMN]}")
    if period_filter is not None:
        print(f"Periodo applicato: {period_start} -> {period_end}")
    print(f"\nRisultato salvato in: {output_path}")

    return output_path


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Calcola rho di Pearson tra tutte le coppie di colonne stazione "
            "in un CSV (prima colonna = data)."
        )
    )
    parser.add_argument(
        "--period-start",
        default=DEFAULT_PERIOD_START,
        help=(
            "Inizio periodo da analizzare. Usa YYYY-MM-DD per intervallo assoluto "
            "oppure MM-DD per periodo stagionale ricorrente."
        ),
    )
    parser.add_argument(
        "--period-end",
        default=DEFAULT_PERIOD_END,
        help=(
            "Fine periodo da analizzare. Usa YYYY-MM-DD per intervallo assoluto "
            "oppure MM-DD per periodo stagionale ricorrente."
        ),
    )
    parser.add_argument(
        "--input-csv",
        default=str(DEFAULT_INPUT_CSV),
        help=(
            "Percorso del CSV di input. "
           f"Default (da sostituire): {DEFAULT_INPUT_CSV}"
        ),
    )
    parser.add_argument(
        "--output-csv",
        default=str(DEFAULT_OUTPUT_CSV),
        help=(
            "Percorso del CSV di output. "
            f"Default (da sostituire): {DEFAULT_OUTPUT_CSV}"
        ),
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    run(
        input_csv=args.input_csv,
        output_csv=args.output_csv,
        period_start=args.period_start,
        period_end=args.period_end,
    )


if __name__ == "__main__":
    main()
