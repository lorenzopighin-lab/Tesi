#!/usr/bin/env python3
"""Conta quante stazioni hanno dati di precipitazione (RS) per ogni anno.

Ogni file TXT nella cartella rappresenta una stazione. Il separatore Ã¨ ';'.
Si usano le colonne:
- MESS_DATUM (YYYYMMDD)
- RS (valore numerico giornaliero)
"""
from __future__ import annotations

import argparse
import csv
import math
from collections import defaultdict
from pathlib import Path
from typing import Iterable


# Impostazioni rapide (modificale se vuoi lanciare lo script senza parametri)
DEFAULT_TXT_DIR = Path(".")
DEFAULT_START_DATE = "20000101"
DEFAULT_END_DATE = "20201231"


def _parse_year(date_value: str) -> int | None:
    date_value = date_value.strip()
    if len(date_value) != 8 or not date_value.isdigit():
        return None
    return int(date_value[:4])


def _parse_date_int(date_value: str) -> int | None:
    date_value = date_value.strip()
    if len(date_value) != 8 or not date_value.isdigit():
        return None
    return int(date_value)


def _is_valid_number(value: str) -> bool:
    value = value.strip()
    if value == "":
        return False
    try:
        number = float(value)
    except ValueError:
        return False
    return math.isfinite(number)


def _iter_txt_files(txt_dir: Path) -> Iterable[Path]:
    return sorted(txt_dir.glob("*.txt"))


def count_stations_by_year(
    txt_dir: Path,
    start_date: int,
    end_date: int,
) -> dict[int, int]:
    start_year = start_date // 10000
    end_year = end_date // 10000
    counts: dict[int, int] = defaultdict(int)

    for txt_path in _iter_txt_files(txt_dir):
        years_with_data: set[int] = set()
        with txt_path.open("r", encoding="utf-8", newline="") as handle:
            reader = csv.DictReader(handle, delimiter=";")
            if "MESS_DATUM" not in reader.fieldnames or "RS" not in reader.fieldnames:
                raise ValueError(
                    f"File {txt_path} non contiene le colonne richieste: MESS_DATUM, RS"
                )
            for row in reader:
                date_int = _parse_date_int(row.get("MESS_DATUM", ""))
                if date_int is None or date_int < start_date or date_int > end_date:
                    continue
                if not _is_valid_number(row.get("RS", "")):
                    continue
                year = _parse_year(row.get("MESS_DATUM", ""))
                if year is None:
                    continue
                years_with_data.add(year)

        for year in years_with_data:
            counts[year] += 1

    return dict(counts)


def _format_table(counts: dict[int, int], start_year: int, end_year: int) -> str:
    lines = ["Anno;Stazioni_con_dati_RS"]
    for year in range(start_year, end_year + 1):
        lines.append(f"{year};{counts.get(year, 0)}")
    return "\n".join(lines)


def main() -> None:
    parser = argparse.ArgumentParser(
        description=(
            "Conta quante stazioni hanno valori RS per ogni anno nel periodo indicato."
        )
    )
    parser.add_argument(
        "--dir",
        "-d",
        type=Path,
        default=DEFAULT_TXT_DIR,
       help=(
           "Cartella contenente i TXT delle stazioni "
           f"(default: {DEFAULT_TXT_DIR})."
       ),
    )
    parser.add_argument(
        "--start",
        "-s",
        type=str,
        default=DEFAULT_START_DATE,
        help=(
            "Data di inizio nel formato YYYYMMDD "
            f"(default: {DEFAULT_START_DATE})."
        ),
    )
    parser.add_argument(
        "--end",
        "-e",
        type=str,
        default=DEFAULT_END_DATE,
        help=(
            "Data di fine nel formato YYYYMMDD "
            f"(default: {DEFAULT_END_DATE})."
        ),
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=None,
        help="Se fornito, salva il risultato in questo file di testo.",
    )

    args = parser.parse_args()
    txt_dir: Path = args.dir
    if not txt_dir.exists() or not txt_dir.is_dir():
        raise SystemExit(f"Cartella non valida: {txt_dir}")

    start_date = _parse_date_int(args.start)
    if start_date is None:
        raise SystemExit("Data di inizio non valida. Usa il formato YYYYMMDD.")

    end_date = _parse_date_int(args.end)
    if end_date is None:
        raise SystemExit("Data di fine non valida. Usa il formato YYYYMMDD.")

    if start_date > end_date:
        raise SystemExit("La data di inizio deve essere <= della data di fine.")

    start_year = start_date // 10000
    end_year = end_date // 10000
    counts = count_stations_by_year(txt_dir, start_date, end_date)
    table = _format_table(counts, start_year, end_year)

    if args.output:
        args.output.write_text(table, encoding="utf-8")
        print(f"Risultato salvato in: {args.output}")
    else:
        print(table)


if __name__ == "__main__":
    main()
